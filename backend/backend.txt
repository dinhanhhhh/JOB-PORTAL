C√ÇY TH∆Ø M·ª§C D·ª∞ √ÅN:

backend
‚îú‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ Job Portal API - Complete.json
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ config
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ db.ts
‚îÇ   ‚îú‚îÄ‚îÄ controllers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ admin.controller.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application.controller.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.controller.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ company.controller.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ job.controller.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ profile.controller.ts
‚îÇ   ‚îú‚îÄ‚îÄ index.ts
‚îÇ   ‚îú‚îÄ‚îÄ middlewares
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ errorHandler.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rateLimit.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ upload.ts
‚îÇ   ‚îú‚îÄ‚îÄ models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Application.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Company.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Job.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SeekerProfile.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ User.ts
‚îÇ   ‚îú‚îÄ‚îÄ routes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ admin.routes.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ai.routes.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application.routes.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.routes.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ company.routes.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ job.routes.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ profile.routes.ts
‚îÇ   ‚îú‚îÄ‚îÄ seed.ts
‚îÇ   ‚îú‚îÄ‚îÄ server.ts
‚îÇ   ‚îú‚îÄ‚îÄ services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cloudinary.service.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ gemini.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ types
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ common.ts
‚îÇ   ‚îî‚îÄ‚îÄ utils
‚îÇ       ‚îú‚îÄ‚îÄ env.ts
‚îÇ       ‚îú‚îÄ‚îÄ jwt.ts
‚îÇ       ‚îî‚îÄ‚îÄ pagination.ts
‚îî‚îÄ‚îÄ tsconfig.json


================================================================================

// START OF FILE: backend/.env.example

# Server
PORT=4000
NODE_ENV=development

# Frontend
FRONTEND_URL=http://localhost:3000

# Database
MONGODB_URI=mongodb://localhost:27017/job-portal
# Production example:
# MONGODB_URI=mongodb+srv://username:password@cluster.mongodb.net/job-portal

# JWT
JWT_ACCESS_SECRET=your-super-secret-access-key-min-32-characters-long-change-in-production
JWT_ACCESS_EXPIRES=15m
JWT_REFRESH_SECRET=your-super-secret-refresh-key-min-32-characters-long-change-in-production
JWT_REFRESH_EXPIRES=7d

# Cookie
COOKIE_SECURE=false  # true in production with HTTPS

# Cloudinary (Get from cloudinary.com)
CLOUDINARY_CLOUD_NAME=your-cloud-name
CLOUDINARY_API_KEY=your-api-key
CLOUDINARY_API_SECRET=your-api-secret

# Google Gemini AI (Get from ai.google.dev)
GEMINI_API_KEY=your-gemini-api-key

# Upload limits
MAX_FILE_SIZE=5242880  # 5MB in bytes
AI_RATE_LIMIT_PER_MIN=5


// END OF FILE: backend/.env.example

// START OF FILE: backend/Job Portal API - Complete.json

{
  "info": {
    "name": "Job Portal API - Complete",
    "description": "Full test suite cho Job Portal Backend (45+ endpoints)",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "variable": [
    {
      "key": "base_url",
      "value": "http://localhost:4000",
      "type": "string"
    },
    {
      "key": "job_id",
      "value": "",
      "type": "string"
    },
    {
      "key": "application_id",
      "value": "",
      "type": "string"
    }
  ],
  "item": [
    {
      "name": "üîê Authentication",
      "item": [
        {
          "name": "Register (Seeker)",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Status 201', () => pm.response.to.have.status(201));",
                  "pm.test('Has user object', () => {",
                  "  const json = pm.response.json();",
                  "  pm.expect(json.user).to.have.property('email');",
                  "});"
                ]
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [{ "key": "Content-Type", "value": "application/json" }],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"seeker@example.com\",\n  \"password\": \"seeker123\",\n  \"name\": \"John Seeker\",\n  \"role\": \"seeker\"\n}"
            },
            "url": "{{base_url}}/api/auth/register"
          }
        },
        {
          "name": "Register (Employer)",
          "request": {
            "method": "POST",
            "header": [{ "key": "Content-Type", "value": "application/json" }],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"employer@example.com\",\n  \"password\": \"employer123\",\n  \"name\": \"Jane Employer\",\n  \"role\": \"employer\"\n}"
            },
            "url": "{{base_url}}/api/auth/register"
          }
        },
        {
          "name": "Login (Employer)",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Status 200', () => pm.response.to.have.status(200));",
                  "pm.test('Cookies set', () => {",
                  "  pm.expect(pm.cookies.get('access_token')).to.not.be.undefined;",
                  "  pm.expect(pm.cookies.get('refresh_token')).to.not.be.undefined;",
                  "});"
                ]
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [{ "key": "Content-Type", "value": "application/json" }],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"hr@example.com\",\n  \"password\": \"hr12345\"\n}"
            },
            "url": "{{base_url}}/api/auth/login"
          }
        },
        {
          "name": "Login (Seeker)",
          "request": {
            "method": "POST",
            "header": [{ "key": "Content-Type", "value": "application/json" }],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"dev@example.com\",\n  \"password\": \"dev12345\"\n}"
            },
            "url": "{{base_url}}/api/auth/login"
          }
        },
        {
          "name": "Login (Admin)",
          "request": {
            "method": "POST",
            "header": [{ "key": "Content-Type", "value": "application/json" }],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"admin@example.com\",\n  \"password\": \"admin123\"\n}"
            },
            "url": "{{base_url}}/api/auth/login"
          }
        },
        {
          "name": "Get Current User",
          "request": {
            "method": "GET",
            "url": "{{base_url}}/api/auth/me"
          }
        },
        {
          "name": "Refresh Token",
          "request": {
            "method": "POST",
            "url": "{{base_url}}/api/auth/refresh"
          }
        },
        {
          "name": "Logout",
          "request": {
            "method": "POST",
            "url": "{{base_url}}/api/auth/logout"
          }
        }
      ]
    },
    {
      "name": "üè¢ Company (Employer)",
      "item": [
        {
          "name": "Get My Company",
          "request": {
            "method": "GET",
            "url": "{{base_url}}/api/company/me"
          }
        },
        {
          "name": "Create/Update Company",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Status 200', () => pm.response.to.have.status(200));",
                  "pm.test('Has company', () => {",
                  "  const json = pm.response.json();",
                  "  pm.expect(json.company).to.have.property('name');",
                  "});"
                ]
              }
            }
          ],
          "request": {
            "method": "PUT",
            "header": [{ "key": "Content-Type", "value": "application/json" }],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"name\": \"TechCorp Solutions\",\n  \"description\": \"Leading tech company\",\n  \"website\": \"https://techcorp.example.com\",\n  \"location\": \"Ho Chi Minh City\",\n  \"industry\": \"Technology\",\n  \"size\": \"51-200\"\n}"
            },
            "url": "{{base_url}}/api/company/me"
          }
        },
        {
          "name": "Upload Company Logo",
          "request": {
            "method": "POST",
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "image",
                  "type": "file",
                  "src": "/path/to/logo.png"
                }
              ]
            },
            "url": "{{base_url}}/api/company/logo"
          }
        }
      ]
    },
    {
      "name": "üíº Jobs",
      "item": [
        {
          "name": "List Jobs (Public)",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Status 200', () => pm.response.to.have.status(200));",
                  "pm.test('Has pagination', () => {",
                  "  const json = pm.response.json();",
                  "  pm.expect(json).to.have.property('pagination');",
                  "});"
                ]
              }
            }
          ],
          "request": {
            "method": "GET",
            "url": {
              "raw": "{{base_url}}/api/jobs?page=1&limit=10",
              "host": ["{{base_url}}"],
              "path": ["api", "jobs"],
              "query": [
                { "key": "page", "value": "1" },
                { "key": "limit", "value": "10" }
              ]
            }
          }
        },
        {
          "name": "Search Jobs",
          "request": {
            "method": "GET",
            "url": {
              "raw": "{{base_url}}/api/jobs?q=react&skills=react,typescript&isRemote=true&level=mid",
              "host": ["{{base_url}}"],
              "path": ["api", "jobs"],
              "query": [
                { "key": "q", "value": "react" },
                { "key": "skills", "value": "react,typescript" },
                { "key": "isRemote", "value": "true" },
                { "key": "level", "value": "mid" }
              ]
            }
          }
        },
        {
          "name": "Get Job by ID",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "const json = pm.response.json();",
                  "if (json.job && json.job._id) {",
                  "  pm.collectionVariables.set('job_id', json.job._id);",
                  "}"
                ]
              }
            }
          ],
          "request": {
            "method": "GET",
            "url": "{{base_url}}/api/jobs/{{job_id}}"
          }
        },
        {
          "name": "Create Job (Employer)",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "const json = pm.response.json();",
                  "if (json.job && json.job._id) {",
                  "  pm.collectionVariables.set('job_id', json.job._id);",
                  "}"
                ]
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [{ "key": "Content-Type", "value": "application/json" }],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"title\": \"Senior React Developer\",\n  \"description\": \"We are looking for an experienced React developer...\",\n  \"requirements\": [\"5+ years React\", \"TypeScript expert\"],\n  \"skills\": [\"React\", \"TypeScript\", \"Node.js\"],\n  \"location\": \"Ho Chi Minh City\",\n  \"isRemote\": false,\n  \"salaryMin\": 2000,\n  \"salaryMax\": 3500,\n  \"level\": \"senior\",\n  \"type\": \"full-time\"\n}"
            },
            "url": "{{base_url}}/api/jobs"
          }
        },
        {
          "name": "Update Job",
          "request": {
            "method": "PUT",
            "header": [{ "key": "Content-Type", "value": "application/json" }],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"description\": \"Updated job description\",\n  \"salaryMax\": 4000\n}"
            },
            "url": "{{base_url}}/api/jobs/{{job_id}}"
          }
        },
        {
          "name": "Toggle Job Status",
          "request": {
            "method": "PATCH",
            "url": "{{base_url}}/api/jobs/{{job_id}}/toggle-status"
          }
        },
        {
          "name": "Delete Job",
          "request": {
            "method": "DELETE",
            "url": "{{base_url}}/api/jobs/{{job_id}}"
          }
        },
        {
          "name": "Get My Jobs (Employer)",
          "request": {
            "method": "GET",
            "url": "{{base_url}}/api/jobs/employer/my-jobs"
          }
        }
      ]
    },
    {
      "name": "üë§ Profile (Seeker)",
      "item": [
        {
          "name": "Get My Profile",
          "request": {
            "method": "GET",
            "url": "{{base_url}}/api/profile/seeker"
          }
        },
        {
          "name": "Update Profile",
          "request": {
            "method": "PUT",
            "header": [{ "key": "Content-Type", "value": "application/json" }],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"phone\": \"+84 123 456 789\",\n  \"location\": \"Ho Chi Minh City\",\n  \"bio\": \"Passionate developer with 3 years experience\",\n  \"skills\": [\"React\", \"Node.js\", \"MongoDB\"],\n  \"experience\": \"3 years\",\n  \"education\": \"Bachelor of CS\",\n  \"github\": \"https://github.com/johndoe\",\n  \"portfolio\": \"https://johndoe.dev\",\n  \"linkedin\": \"https://linkedin.com/in/johndoe\"\n}"
            },
            "url": "{{base_url}}/api/profile/seeker"
          }
        },
        {
          "name": "Upload Avatar",
          "request": {
            "method": "POST",
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "image",
                  "type": "file",
                  "src": "/path/to/avatar.jpg"
                }
              ]
            },
            "url": "{{base_url}}/api/profile/seeker/avatar"
          }
        },
        {
          "name": "Upload Resume",
          "request": {
            "method": "POST",
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "resume",
                  "type": "file",
                  "src": "/path/to/resume.pdf"
                }
              ]
            },
            "url": "{{base_url}}/api/profile/seeker/resume"
          }
        }
      ]
    },
    {
      "name": "üìÑ Applications",
      "item": [
        {
          "name": "Apply to Job (Seeker)",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "const json = pm.response.json();",
                  "if (json.application && json.application._id) {",
                  "  pm.collectionVariables.set('application_id', json.application._id);",
                  "}"
                ]
              }
            }
          ],
          "request": {
            "method": "POST",
            "body": {
              "mode": "formdata",
              "formdata": [
                {
                  "key": "resume",
                  "type": "file",
                  "src": "/path/to/resume.pdf"
                },
                {
                  "key": "coverLetter",
                  "value": "I am interested in this position...",
                  "type": "text"
                }
              ]
            },
            "url": "{{base_url}}/api/applications/jobs/{{job_id}}/apply"
          }
        },
        {
          "name": "Get My Applications (Seeker)",
          "request": {
            "method": "GET",
            "url": "{{base_url}}/api/applications/my-applications"
          }
        },
        {
          "name": "Get Job Applications (Employer)",
          "request": {
            "method": "GET",
            "url": "{{base_url}}/api/applications/jobs/{{job_id}}/applications"
          }
        },
        {
          "name": "Update Application Status",
          "request": {
            "method": "PATCH",
            "header": [{ "key": "Content-Type", "value": "application/json" }],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"status\": \"viewed\"\n}"
            },
            "url": "{{base_url}}/api/applications/{{application_id}}/status"
          }
        },
        {
          "name": "Get Application Detail",
          "request": {
            "method": "GET",
            "url": "{{base_url}}/api/applications/{{application_id}}"
          }
        },
        {
          "name": "Generate Cover Letter (AI)",
          "request": {
            "method": "POST",
            "header": [{ "key": "Content-Type", "value": "application/json" }],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"jobId\": \"{{job_id}}\"\n}"
            },
            "url": "{{base_url}}/api/applications/generate-cover-letter"
          }
        },
        {
          "name": "Summarize Candidate (AI)",
          "request": {
            "method": "POST",
            "url": "{{base_url}}/api/applications/{{application_id}}/summarize"
          }
        }
      ]
    },
    {
      "name": "‚öôÔ∏è Admin",
      "item": [
        {
          "name": "Get Statistics",
          "request": {
            "method": "GET",
            "url": "{{base_url}}/api/admin/stats"
          }
        }
      ]
    },
    {
      "name": "üè• Health Check",
      "request": {
        "method": "GET",
        "url": "{{base_url}}/health"
      }
    }
  ]
}


// END OF FILE: backend/Job Portal API - Complete.json

// START OF FILE: backend/package.json

{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "build": "tsc -p tsconfig.json",
    "start": "node dist/index.js",
    "seed": "ts-node src/seed.ts"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "@google/genai": "^1.27.0",
    "@google/generative-ai": "^0.24.1",
    "bcryptjs": "^3.0.2",
    "cloudinary": "^2.8.0",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.1.0",
    "jsonwebtoken": "^9.0.2",
    "mongodb": "^6.20.0",
    "mongoose": "^8.19.2",
    "multer": "^2.0.2",
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cookie-parser": "^1.4.9",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.3",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/ms": "^2.1.0",
    "@types/multer": "^2.0.0",
    "@types/node": "^24.9.1",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.9.3"
  }
}


// END OF FILE: backend/package.json

// START OF FILE: backend/README.md

# üöÄ Job Portal Backend API

> Backend API cho ·ª©ng d·ª•ng t√¨m vi·ªác l√†m v·ªõi Node.js + Express + MongoDB + TypeScript

[![TypeScript](https://img.shields.io/badge/TypeScript-5.3-blue)](https://www.typescriptlang.org/)
[![Node.js](https://img.shields.io/badge/Node.js-18+-green)](https://nodejs.org/)
[![Express](https://img.shields.io/badge/Express-4.18-lightgrey)](https://expressjs.com/)
[![MongoDB](https://img.shields.io/badge/MongoDB-7.0-brightgreen)](https://www.mongodb.com/)

---

## üìã M·ª•c L·ª•c

- [T√≠nh nƒÉng](#-t√≠nh-nƒÉng)
- [C√¥ng ngh·ªá](#-c√¥ng-ngh·ªá)
- [C√†i ƒë·∫∑t](#-c√†i-ƒë·∫∑t)
- [C·∫•u h√¨nh](#-c·∫•u-h√¨nh)
- [Ch·∫°y ·ª©ng d·ª•ng](#-ch·∫°y-·ª©ng-d·ª•ng)
- [Seed d·ªØ li·ªáu](#-seed-d·ªØ-li·ªáu)
- [API Endpoints](#-api-endpoints)
- [C·∫•u tr√∫c th∆∞ m·ª•c](#-c·∫•u-tr√∫c-th∆∞-m·ª•c)
- [Testing](#-testing)
- [Deployment](#-deployment)
- [T√†i kho·∫£n demo](#-t√†i-kho·∫£n-demo)

---

## ‚ú® T√≠nh NƒÉng

### **üîê Authentication & Authorization**
- ‚úÖ JWT Authentication v·ªõi HTTP-only cookies
- ‚úÖ Access Token (15 ph√∫t) + Refresh Token (7 ng√†y)
- ‚úÖ Auto-refresh token trong middleware
- ‚úÖ RBAC v·ªõi 3 roles: **Seeker**, **Employer**, **Admin**

### **üíº Qu·∫£n L√Ω C√¥ng Vi·ªác**
- ‚úÖ CRUD operations cho jobs
- ‚úÖ Filter & search: t√™n, ƒë·ªãa ƒëi·ªÉm, remote, skills, level, m·ª©c l∆∞∆°ng
- ‚úÖ Pagination
- ‚úÖ Toggle tr·∫°ng th√°i active/inactive

### **üìÑ Qu·∫£n L√Ω H·ªì S∆°**
- ‚úÖ H·ªì s∆° Seeker (skills, experience, education, portfolio)
- ‚úÖ Upload avatar v√† CV (Cloudinary)
- ‚úÖ H·ªì s∆° c√¥ng ty (Employer)
- ‚úÖ Upload logo c√¥ng ty

### **üì® ·ª®ng Tuy·ªÉn**
- ‚úÖ Seeker apply job v·ªõi CV
- ‚úÖ Employer xem danh s√°ch ·ª©ng vi√™n
- ‚úÖ C·∫≠p nh·∫≠t tr·∫°ng th√°i: submitted ‚Üí viewed ‚Üí accepted/rejected
- ‚úÖ Theo d√µi th·ªùi gian xem v√† ph·∫£n h·ªìi

### **ü§ñ AI Features (Google Gemini)**
- ‚úÖ T·∫°o cover letter t·ª± ƒë·ªông
- ‚úÖ T·∫°o job description t·ª± ƒë·ªông
- ‚úÖ T√≥m t·∫Øt h·ªì s∆° ·ª©ng vi√™n

### **üìä Admin Dashboard**
- ‚úÖ Th·ªëng k√™ users, jobs, applications
- ‚úÖ Th·ªëng k√™ theo role v√† status
- ‚úÖ Recent activities

---

## üõ†Ô∏è C√¥ng Ngh·ªá

### **Core**
- **Node.js** (v18+) - JavaScript runtime
- **Express** (v4.18) - Web framework
- **TypeScript** (v5.3) - Type safety
- **MongoDB** (v7.0) - Database
- **Mongoose** (v8.0) - ODM

### **Security & Auth**
- **jsonwebtoken** - JWT authentication
- **bcryptjs** - Password hashing
- **cookie-parser** - Cookie handling
- **cors** - Cross-Origin Resource Sharing

### **Validation & Upload**
- **zod** - Schema validation
- **multer** - File upload middleware
- **cloudinary** - Cloud storage

### **AI**
- **@google/generative-ai** - Google Gemini API

### **Dev Tools**
- **ts-node-dev** - Development with hot reload
- **dotenv** - Environment variables

---

## üì¶ C√†i ƒê·∫∑t

### **Y√™u c·∫ßu**
- Node.js >= 18.0.0
- npm >= 9.0.0
- MongoDB (local ho·∫∑c Atlas)
- Cloudinary account
- Google Gemini API key

### **Clone & Install**



// END OF FILE: backend/README.md

// START OF FILE: backend/src/config/db.ts

import mongoose from "mongoose";
import { env } from "../utils/env";

export async function connectDB(): Promise<void> {
  try {
    await mongoose.connect(env.MONGODB_URI);
    console.log("‚úÖ MongoDB connected");
  } catch (err) {
    console.error("‚ùå MongoDB connection error:", err);
    process.exit(1);
  }
}


// END OF FILE: backend/src/config/db.ts

// START OF FILE: backend/src/controllers/admin.controller.ts

import type { Request, Response } from "express";
import { z } from "zod";
import User from "../models/User";
import Job from "../models/Job";
import Application from "../models/Application";

/**
 * GET /api/admin/stats
 * Th·ªëng k√™ chi ti·∫øt h·ªá th·ªëng
 */
export async function getStats(_req: Request, res: Response): Promise<void> {
  try {
    const [
      totalUsers,
      totalJobs,
      totalApplications,
      activeJobs,
      usersByRole,
      applicationsByStatus,
      recentJobs,
      recentApplications,
    ] = await Promise.all([
      User.countDocuments(),
      Job.countDocuments(),
      Application.countDocuments(),
      Job.countDocuments({ isActive: true }),

      // ‚úÖ Users by role
      User.aggregate([{ $group: { _id: "$role", count: { $sum: 1 } } }]).then(
        (results) =>
          results.reduce((acc, { _id, count }) => ({ ...acc, [_id]: count }), {
            seeker: 0,
            employer: 0,
            admin: 0,
          })
      ),

      // ‚úÖ Applications by status
      Application.aggregate([
        { $group: { _id: "$status", count: { $sum: 1 } } },
      ]).then((results) =>
        results.reduce((acc, { _id, count }) => ({ ...acc, [_id]: count }), {
          submitted: 0,
          viewed: 0,
          accepted: 0,
          rejected: 0,
        })
      ),

      // ‚úÖ Recent jobs (last 5)
      Job.find()
        .populate("company")
        .populate("employer", "name email")
        .sort({ createdAt: -1 })
        .limit(5),

      // ‚úÖ Recent applications (last 5)
      Application.find()
        .populate("job", "title")
        .populate("seeker", "name email")
        .sort({ createdAt: -1 })
        .limit(5),
    ]);

    res.json({
      stats: {
        totalUsers,
        totalJobs,
        totalApplications,
        activeJobs,
        usersByRole,
        applicationsByStatus,
      },
      recentActivities: {
        recentJobs,
        recentApplications,
      },
    });
  } catch (error) {
    console.error("Get stats error:", error);
    res.status(500).json({ message: "Failed to fetch statistics" });
  }
}

/**
 * GET /api/admin/users
 * Danh s√°ch users v·ªõi filter
 */
export async function getUsers(req: Request, res: Response): Promise<void> {
  try {
    const { page = "1", limit = "10", role, search } = req.query;

    const pageNum = Math.max(1, parseInt(page as string, 10));
    const limitNum = Math.min(100, Math.max(1, parseInt(limit as string, 10)));
    const skip = (pageNum - 1) * limitNum;

    const filter: Record<string, unknown> = {};

    if (role && ["seeker", "employer", "admin"].includes(role as string)) {
      filter.role = role;
    }

    if (search) {
      filter.$or = [
        { name: { $regex: search, $options: "i" } },
        { email: { $regex: search, $options: "i" } },
      ];
    }

    const [users, total] = await Promise.all([
      User.find(filter)
        .select("-password")
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limitNum),
      User.countDocuments(filter),
    ]);

    res.json({
      data: users,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total,
        totalPages: Math.ceil(total / limitNum),
      },
    });
  } catch (error) {
    res.status(500).json({ message: "Failed to fetch users" });
  }
}

/**
 * PATCH /api/admin/users/:userId
 * C·∫≠p nh·∫≠t user (role, isActive)
 */
export async function updateUser(req: Request, res: Response): Promise<void> {
  try {
    const adminId = req.user?.id;
    const { userId } = req.params;

    const validated = z
      .object({
        isActive: z.boolean().optional(),
        role: z.enum(["seeker", "employer", "admin"]).optional(),
      })
      .parse(req.body);

    // ‚úÖ Prevent self-modification
    if (adminId === userId) {
      res.status(400).json({ message: "Cannot modify your own account" });
      return;
    }

    const user = await User.findByIdAndUpdate(userId, validated, {
      new: true,
    }).select("-password");

    if (!user) {
      res.status(404).json({ message: "User not found" });
      return;
    }

    res.json({ message: "User updated successfully", user });
  } catch (error) {
    if (error instanceof z.ZodError) {
      res
        .status(400)
        .json({ message: "Validation error", errors: error.flatten() });
      return;
    }
    res.status(500).json({ message: "Failed to update user" });
  }
}

/**
 * GET /api/admin/jobs
 * T·∫•t c·∫£ jobs (admin view)
 */
export async function getAllJobs(req: Request, res: Response): Promise<void> {
  try {
    const { page = "1", limit = "10" } = req.query;

    const pageNum = Math.max(1, parseInt(page as string, 10));
    const limitNum = Math.min(100, Math.max(1, parseInt(limit as string, 10)));
    const skip = (pageNum - 1) * limitNum;

    const [jobs, total] = await Promise.all([
      Job.find()
        .populate("company")
        .populate("employer", "name email")
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limitNum),
      Job.countDocuments(),
    ]);

    res.json({
      data: jobs,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total,
        totalPages: Math.ceil(total / limitNum),
      },
    });
  } catch (error) {
    res.status(500).json({ message: "Failed to fetch jobs" });
  }
}

/**
 * DELETE /api/admin/jobs/:jobId
 * X√≥a job (admin only)
 */
export async function deleteJobByAdmin(
  req: Request,
  res: Response
): Promise<void> {
  try {
    const { jobId } = req.params;

    const job = await Job.findByIdAndDelete(jobId);

    if (!job) {
      res.status(404).json({ message: "Job not found" });
      return;
    }

    // ‚úÖ X√≥a applications li√™n quan
    await Application.deleteMany({ job: jobId });

    res.json({
      message: "Job and related applications deleted successfully",
    });
  } catch (error) {
    res.status(500).json({ message: "Failed to delete job" });
  }
}


// END OF FILE: backend/src/controllers/admin.controller.ts

// START OF FILE: backend/src/controllers/application.controller.ts

import type { Request, Response } from "express";
import { z } from "zod";
import Application from "../models/Application";
import Job from "../models/Job";
import SeekerProfile from "../models/SeekerProfile";
import { uploadToCloudinary } from "../services/cloudinary.service";
import {
  generateCoverLetter,
  summarizeCandidate,
} from "../services/gemini.service";
import User from "../models/User";

// Validation schemas
const applyJobSchema = z.object({
  coverLetter: z
    .string()
    .max(1000, "Cover letter cannot exceed 1000 characters")
    .optional(),
});

const updateStatusSchema = z.object({
  status: z.enum(["submitted", "viewed", "accepted", "rejected"]),
});

/**
 * POST /api/applications/:jobId/apply
 * Apply to a job (Seeker only)
 */
export async function applyToJob(req: Request, res: Response): Promise<void> {
  try {
    const seekerId = req.user?.id;
    const { jobId } = req.params;

    if (!seekerId) {
      res.status(401).json({ message: "Unauthorized" });
      return;
    }

    const validated = applyJobSchema.parse(req.body);

    // Check if job exists and is open
    const job = await Job.findById(jobId);
    if (!job) {
      res.status(404).json({ message: "Job not found" });
      return;
    }

    if (!job.isActive) {
      res
        .status(400)
        .json({ message: "This job is no longer accepting applications" });
      return;
    }

    // Get seeker's profile
    const profile = await SeekerProfile.findOne({ user: seekerId });
    if (!profile) {
      res.status(400).json({ message: "Please complete your profile first" });
      return;
    }

    // Check if already applied
    const existingApp = await Application.findOne({
      job: jobId,
      seeker: seekerId,
    });

    if (existingApp) {
      res.status(400).json({ message: "You have already applied to this job" });
      return;
    }

    // Use resume from profile or upload new one
    let resumeUrl = profile.resumeUrl;

    if (req.file) {
      const result = await uploadToCloudinary(
        req.file.path,
        "applications",
        "raw"
      );
      resumeUrl = result.secure_url;
    }

    if (!resumeUrl) {
      res.status(400).json({
        message:
          "Resume is required. Please upload a resume or add one to your profile.",
      });
      return;
    }

    // Create application
    const application = await Application.create({
      job: jobId,
      seeker: seekerId,
      resumeUrl,
      coverLetter: validated.coverLetter,
      status: "submitted",
    });

    await application.populate([
      { path: "job", populate: { path: "company" } },
      { path: "seeker", select: "name email" },
    ]);

    res.status(201).json({
      message: "Application submitted successfully",
      application,
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      res
        .status(400)
        .json({ message: "Validation error", errors: error.flatten() });
      return;
    }
    res.status(500).json({ message: "Failed to submit application" });
  }
}

/**
 * GET /api/applications/my-applications
 * Get seeker's applications
 */
export async function getMyApplications(
  req: Request,
  res: Response
): Promise<void> {
  try {
    const seekerId = req.user?.id;

    const applications = await Application.find({ seeker: seekerId })
      .populate({
        path: "job",
        populate: { path: "company" },
      })
      .sort({ createdAt: -1 });

    res.json({ applications });
  } catch (error) {
    res.status(500).json({ message: "Failed to fetch applications" });
  }
}

/**
 * GET /api/applications/job/:jobId
 * Get all applications for a job (Employer only)
 */
export async function getJobApplications(
  req: Request,
  res: Response
): Promise<void> {
  try {
    const employerId = req.user?.id;
    const { jobId } = req.params;

    // Verify job belongs to employer
    const job = await Job.findOne({
      _id: jobId,
      employer: employerId,
    });

    if (!job) {
      res.status(404).json({ message: "Job not found or unauthorized" });
      return;
    }

    const applications = await Application.find({ job: jobId })
      .populate({
        path: "seeker",
        select: "name email",
      })
      .sort({ createdAt: -1 });

    // Fetch seeker profiles separately
    const applicationsWithProfiles = await Promise.all(
      applications.map(async (app) => {
        const profile = await SeekerProfile.findOne({ user: app.seeker });
        return {
          ...app.toObject(),
          seekerProfile: profile,
        };
      })
    );

    res.json({ applications: applicationsWithProfiles });
  } catch (error) {
    res.status(500).json({ message: "Failed to fetch applications" });
  }
}

/**
 * PATCH /api/applications/:applicationId/status
 * Update application status (Employer only)
 */
export async function updateApplicationStatus(
  req: Request,
  res: Response
): Promise<void> {
  try {
    const employerId = req.user?.id;
    const { applicationId } = req.params;

    const validated = updateStatusSchema.parse(req.body);

    const application = await Application.findById(applicationId).populate(
      "job"
    );

    if (!application) {
      res.status(404).json({ message: "Application not found" });
      return;
    }

    // Verify job belongs to employer
    const job = await Job.findOne({
      _id: application.job,
      employer: employerId,
    });

    if (!job) {
      res
        .status(403)
        .json({ message: "Unauthorized to update this application" });
      return;
    }

    // Update status
    application.status = validated.status;

    if (validated.status === "viewed" && !application.viewedAt) {
      application.viewedAt = new Date();
    }

    if (
      ["accepted", "rejected"].includes(validated.status) &&
      !application.respondedAt
    ) {
      application.respondedAt = new Date();
    }

    await application.save();

    res.json({
      message: "Application status updated successfully",
      application,
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      res.status(400).json({ message: "Validation error" });
      return;
    }
    res.status(500).json({ message: "Failed to update application status" });
  }
}

/**
 * GET /api/applications/:applicationId
 * Get application details
 */
export async function getApplicationById(
  req: Request,
  res: Response
): Promise<void> {
  try {
    const userId = req.user?.id;
    const userRole = req.user?.role;
    const { applicationId } = req.params;

    const application = await Application.findById(applicationId)
      .populate({
        path: "job",
        populate: { path: "company" },
      })
      .populate({
        path: "seeker",
        select: "name email",
      });

    if (!application) {
      res.status(404).json({ message: "Application not found" });
      return;
    }

    // Authorization check
    if (userRole === "seeker") {
      if (application.seeker._id.toString() !== userId) {
        res.status(403).json({ message: "Unauthorized" });
        return;
      }
    } else if (userRole === "employer") {
      const job = await Job.findOne({
        _id: application.job,
        employer: userId,
      });

      if (!job) {
        res.status(403).json({ message: "Unauthorized" });
        return;
      }
    }

    // Get seeker profile
    const profile = await SeekerProfile.findOne({ user: application.seeker });

    res.json({
      application,
      seekerProfile: profile,
    });
  } catch (error) {
    res.status(500).json({ message: "Failed to fetch application" });
  }
}

/**
 * POST /api/applications/generate-cover-letter
 * Generate cover letter using AI (Seeker only)
 */
export async function generateCoverLetterAI(
  req: Request,
  res: Response
): Promise<void> {
  try {
    const seekerId = req.user?.id;

    const { jobId } = z.object({ jobId: z.string() }).parse(req.body);

    // Get job details
    const job = await Job.findById(jobId);
    if (!job) {
      res.status(404).json({ message: "Job not found" });
      return;
    }

    // Get seeker profile
    const profile = await SeekerProfile.findOne({ user: seekerId });
    const user = await User.findById(seekerId);

    if (!profile || !user) {
      res.status(400).json({ message: "Please complete your profile first" });
      return;
    }

    const coverLetter = await generateCoverLetter(job.title, job.description, {
      name: user.name,
      skills: profile.skills,
      experience: profile.experience,
    });

    res.json({ coverLetter });
  } catch (error) {
    if (error instanceof z.ZodError) {
      res.status(400).json({ message: "Validation error" });
      return;
    }
    res.status(500).json({ message: "Failed to generate cover letter" });
  }
}

/**
 * POST /api/applications/:applicationId/summarize
 * Summarize candidate using AI (Employer only)
 */
export async function summarizeCandidateAI(
  req: Request,
  res: Response
): Promise<void> {
  try {
    const employerId = req.user?.id;
    const { applicationId } = req.params;

    const application = await Application.findById(applicationId).populate(
      "job"
    );

    if (!application) {
      res.status(404).json({ message: "Application not found" });
      return;
    }

    // Verify authorization
    const job = await Job.findOne({
      _id: application.job,
      employer: employerId,
    });

    if (!job) {
      res.status(403).json({ message: "Unauthorized" });
      return;
    }

    // Get seeker profile
    const profile = await SeekerProfile.findOne({ user: application.seeker });

    if (!profile) {
      res.status(404).json({ message: "Candidate profile not found" });
      return;
    }

    // Build resume text from profile
    const resumeText = `
Skills: ${profile.skills.join(", ")}
Experience: ${profile.experience || "N/A"}
Education: ${profile.education || "N/A"}
Bio: ${profile.bio || "N/A"}
    `.trim();

    const jobRequirements = `
Title: ${job.title}
Required Skills: ${job.skills.join(", ")}
Description: ${job.description}
    `.trim();

    const summary = await summarizeCandidate(resumeText, jobRequirements);

    res.json({ summary });
  } catch (error) {
    res.status(500).json({ message: "Failed to summarize candidate" });
  }
}


// END OF FILE: backend/src/controllers/application.controller.ts

// START OF FILE: backend/src/controllers/auth.controller.ts

import type { Request, Response } from "express";
import { z } from "zod";
import User from "../models/User";
import {
  signAccessToken,
  signRefreshToken,
  verifyRefreshToken,
} from "../utils/jwt";

// ===== Zod schemas =====
const registerSchema = z.object({
  email: z.string().email(),
  password: z.string().min(6),
  name: z.string().min(2),
  role: z.enum(["seeker", "employer"]).optional().default("seeker"), // admin seed sau
});
type RegisterDto = z.infer<typeof registerSchema>;

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(6),
});
type LoginDto = z.infer<typeof loginSchema>;

// ===== Helper: set cookies HTTP-only =====
function setAuthCookies(res: Response, access: string, refresh: string): void {
  const secure = (process.env.COOKIE_SECURE ?? "false") === "true";
  // Max-Age ch·ªâ l√† tu·ªïi cookie; token t·ª± h·∫øt h·∫°n theo payload
  res.cookie("access_token", access, {
    httpOnly: true,
    sameSite: "lax",
    secure,
    path: "/",
  });
  res.cookie("refresh_token", refresh, {
    httpOnly: true,
    sameSite: "lax",
    secure,
    path: "/",
  });
}

// ===== Controllers =====
export async function register(req: Request, res: Response): Promise<void> {
  const dto: RegisterDto = registerSchema.parse(req.body);

  const exists = await User.findOne({ email: dto.email });
  if (exists) {
    res.status(409).json({ message: "Email already registered" });
    return;
  }

  const user = await User.create({
    ...dto,
    role: dto.role ?? "seeker",
  });

  const access = signAccessToken(user.id, user.role);
  const refresh = signRefreshToken(user.id, user.role);
  setAuthCookies(res, access, refresh);

  res.status(201).json({
    user: {
      id: user.id,
      email: user.email,
      role: user.role,
      name: user.name,
    },
  });
}

export async function login(req: Request, res: Response): Promise<void> {
  const dto: LoginDto = loginSchema.parse(req.body);

  const user = await User.findOne({ email: dto.email });
  if (!user) {
    res.status(401).json({ message: "Invalid credentials" });
    return;
  }

  const ok = await user.comparePassword(dto.password);
  if (!ok) {
    res.status(401).json({ message: "Invalid credentials" });
    return;
  }

  if (!user.isActive) {
    res.status(403).json({ message: "User disabled" });
    return;
  }

  const access = signAccessToken(user.id, user.role);
  const refresh = signRefreshToken(user.id, user.role);
  setAuthCookies(res, access, refresh);

  res.json({
    user: {
      id: user.id,
      email: user.email,
      role: user.role,
      name: user.name,
    },
  });
}

export async function me(req: Request, res: Response): Promise<void> {
  const u = req.user!; // ƒë√£ qua requireAuth
  const user = await User.findById(u.id).select("-password");
  res.json({ user });
}

export async function refresh(req: Request, res: Response): Promise<void> {
  const rt = req.cookies?.refresh_token as string | undefined;
  if (!rt) {
    res.status(401).json({ message: "No refresh token" });
    return;
  }

  try {
    const payload = verifyRefreshToken(rt);
    const user = await User.findById(payload.sub);
    if (!user || !user.isActive) {
      res.status(401).json({ message: "Invalid user" });
      return;
    }

    const access = signAccessToken(user.id, user.role);
    const refreshTok = signRefreshToken(user.id, user.role);
    setAuthCookies(res, access, refreshTok);
    res.json({ ok: true });
  } catch {
    res.status(401).json({ message: "Invalid refresh token" });
  }
}

export async function logout(_req: Request, res: Response): Promise<void> {
  res.clearCookie("access_token", { path: "/" });
  res.clearCookie("refresh_token", { path: "/" });
  res.json({ ok: true });
}


// END OF FILE: backend/src/controllers/auth.controller.ts

// START OF FILE: backend/src/controllers/company.controller.ts

import type { Request, Response } from "express";
import { z } from "zod";
import Company from "../models/Company";
import { MongoServerError } from "mongodb";
import { uploadToCloudinary } from "../services/cloudinary.service"; // ‚úÖ Th√™m import ·ªü ƒë·∫ßu file

const companySchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters long"),
  description: z.string().optional(),
  website: z.string().url("Invalid URL format").optional(),
  logoUrl: z.string().url().optional(),
});

// --- Type guard: ph√°t hi·ªán l·ªói duplicate key (11000) c·ªßa Mongo ---
function isDupKeyError(err: unknown): err is MongoServerError {
  return (
    Boolean(err) &&
    typeof err === "object" &&
    "code" in (err as Record<string, unknown>) &&
    (err as MongoServerError).code === 11000
  );
}

/**
 * GET /api/users/me/company
 * Y√™u c·∫ßu: requireAuth + requireRole(['employer'])
 */
export async function getMyCompany(req: Request, res: Response): Promise<void> {
  const employerId = req.user?.id;
  if (!employerId) {
    res.status(401).json({ message: "Unauthorized" });
    return;
  }

  const company = await Company.findOne({ owner: employerId });
  if (!company) {
    res.status(404).json({ message: "Company profile not found." });
    return;
  }

  res.status(200).json({ company });
}

/**
 * PUT /api/users/me/company
 * Upsert h·ªì s∆° c√¥ng ty c·ªßa employer hi·ªán t·∫°i
 * Y√™u c·∫ßu: requireAuth + requireRole(['employer'])
 */
export async function upsertMyCompany(
  req: Request,
  res: Response
): Promise<void> {
  const employerId = req.user?.id;
  if (!employerId) {
    res.status(401).json({ message: "Unauthorized" });
    return;
  }

  const parsed = companySchema.safeParse(req.body);
  if (!parsed.success) {
    res
      .status(400)
      .json({ message: "Invalid input data", errors: parsed.error.flatten() });
    return;
  }

  try {
    const company = await Company.findOneAndUpdate(
      { owner: employerId },
      { ...parsed.data, owner: employerId },
      { upsert: true, new: true, runValidators: true }
    );
    res.status(200).json({ company });
  } catch (error) {
    if (isDupKeyError(error)) {
      res
        .status(409)
        .json({ message: "A company with this name already exists." });
      return;
    }
    res.status(500).json({ message: "Something went wrong on the server." });
  }
}
/**
 * POST /api/company/logo
 * Upload company logo (Employer only)
 */
export async function uploadLogo(req: Request, res: Response): Promise<void> {
  try {
    const employerId = req.user?.id;

    if (!employerId) {
      res.status(401).json({ message: "Unauthorized" });
      return;
    }

    if (!req.file) {
      res.status(400).json({ message: "No file uploaded" });
      return;
    }

    // Upload to Cloudinary
    const result = await uploadToCloudinary(req.file.path, "company-logos", "image");

    // Update company with new logo URL
    const company = await Company.findOneAndUpdate(
      { owner: employerId },
      { logoUrl: result.secure_url },
      { new: true, upsert: false }
    );

    if (!company) {
      res.status(404).json({ 
        message: "Company not found. Please create company profile first." 
      });
      return;
    }

    res.json({
      message: "Logo uploaded successfully",
      logoUrl: result.secure_url,
      company,
    });
  } catch (error) {
    console.error("Upload logo error:", error);
    res.status(500).json({ message: "Failed to upload logo" });
  }
}

// END OF FILE: backend/src/controllers/company.controller.ts

// START OF FILE: backend/src/controllers/job.controller.ts

import type { Request, Response } from "express";
import { z } from "zod";
import Job from "../models/Job";
import Company from "../models/Company";
import { generateJobDescription } from "../services/gemini.service";

// ‚úÖ Zod schemas
export const createJobSchema = z.object({
  title: z.string().min(3, "Title must be at least 3 characters"),
  description: z.string().min(20, "Description must be at least 20 characters"),
  requirements: z.array(z.string()).optional().default([]),
  skills: z.array(z.string()).min(1, "At least one skill is required"),
  location: z.string().optional(),
  isRemote: z.boolean().optional().default(false),
  salaryMin: z.number().min(0).optional(),
  salaryMax: z.number().min(0).optional(),
  level: z.enum(["entry", "mid", "senior", "lead", "executive"]),
  type: z.enum([
    "full-time",
    "part-time",
    "contract",
    "internship",
    "freelance",
  ]),
});

const updateJobSchema = createJobSchema.partial();

// ‚úÖ Query validation schema
const querySchema = z.object({
  page: z.string().optional().default("1"),
  limit: z.string().optional().default("10"),
  q: z.string().optional(), // ƒê·ªïi t·ª´ search ‚Üí q (theo prompt)
  location: z.string().optional(),
  isRemote: z.enum(["true", "false"]).optional(), // ƒê·ªïi t·ª´ remote ‚Üí isRemote
  level: z.enum(["entry", "mid", "senior", "lead", "executive"]).optional(),
  skills: z.string().optional(),
  salaryMin: z.string().optional(),
  type: z
    .enum(["full-time", "part-time", "contract", "internship", "freelance"])
    .optional(),
});

/**
 * GET /api/jobs
 * Get all jobs with filters and pagination
 */
export async function getJobs(req: Request, res: Response): Promise<void> {
  try {
    // ‚úÖ Validate query params
    const validated = querySchema.parse(req.query);

    const pageNum = Math.max(1, parseInt(validated.page, 10));
    const limitNum = Math.min(100, Math.max(1, parseInt(validated.limit, 10)));
    const skip = (pageNum - 1) * limitNum;

    // ‚úÖ Build filter - isActive thay v√¨ isOpen
    const filter: Record<string, unknown> = { isActive: true };

    // ‚úÖ Text search (q thay v√¨ search)
    if (validated.q) {
      filter.$text = { $search: validated.q };
    }

    if (validated.location) {
      filter.location = new RegExp(validated.location, "i");
    }

    // ‚úÖ isRemote thay v√¨ remote
    if (validated.isRemote !== undefined) {
      filter.isRemote = validated.isRemote === "true";
    }

    if (validated.level) {
      filter.level = validated.level;
    }

    if (validated.type) {
      filter.type = validated.type;
    }

    // ‚úÖ Skills d√πng $all thay v√¨ $in
    if (validated.skills) {
      const skillsArray = validated.skills.split(",").map((s) => s.trim());
      filter.skills = { $all: skillsArray };
    }

    if (validated.salaryMin) {
      const min = parseInt(validated.salaryMin, 10);
      filter.$or = [{ salaryMax: { $gte: min } }, { salaryMin: { $gte: min } }];
    }


    // Execute query
    const [jobs, total] = await Promise.all([
      Job.find(filter)
        .populate("company")
        .populate("employer", "email name")
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limitNum),
      Job.countDocuments(filter),
    ]);

    res.json({
      data: jobs,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total,
        totalPages: Math.ceil(total / limitNum),
      },
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      res.status(400).json({
        message: "Invalid query parameters",
        errors: error.flatten(),
      });
      return;
    }
    res.status(500).json({ message: "Failed to fetch jobs" });
  }
}

/**
 * GET /api/jobs/:id
 * Get job by ID
 */
export async function getJobById(req: Request, res: Response): Promise<void> {
  try {
    const job = await Job.findById(req.params.id)
      .populate("company")
      .populate("employer", "email name");

    if (!job) {
      res.status(404).json({ message: "Job not found" });
      return;
    }

    res.json({ job });
  } catch (error) {
    res.status(500).json({ message: "Failed to fetch job" });
  }
}

/**
 * POST /api/jobs
 * Create new job (Employer only)
 */
export async function createJob(req: Request, res: Response): Promise<void> {
  try {
    const employerId = req.user?.id;
    if (!employerId) {
      res.status(401).json({ message: "Unauthorized" });
      return;
    }

    const validated = createJobSchema.parse(req.body);

    // Get employer's company
    const company = await Company.findOne({ owner: employerId });
    if (!company) {
      res
        .status(400)
        .json({ message: "Please create a company profile first" });
      return;
    }

    // ‚úÖ isActive thay v√¨ isOpen
    const job = await Job.create({
      ...validated,
      employer: employerId,
      company: company._id,
      isActive: true,
    });

    await job.populate("company");

    res.status(201).json({
      message: "Job created successfully",
      job,
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      res
        .status(400)
        .json({ message: "Validation error", errors: error.flatten() });
      return;
    }
    res.status(500).json({ message: "Failed to create job" });
  }
}

/**
 * PUT /api/jobs/:id
 * Update job (Employer only - own jobs)
 */
export async function updateJob(req: Request, res: Response): Promise<void> {
  try {
    const employerId = req.user?.id;
    const validated = updateJobSchema.parse(req.body);

    const job = await Job.findOne({
      _id: req.params.id,
      employer: employerId,
    });

    if (!job) {
      res.status(404).json({ message: "Job not found or unauthorized" });
      return;
    }

    Object.assign(job, validated);
    await job.save();
    await job.populate("company");

    res.json({
      message: "Job updated successfully",
      job,
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      res
        .status(400)
        .json({ message: "Validation error", errors: error.flatten() });
      return;
    }
    res.status(500).json({ message: "Failed to update job" });
  }
}

/**
 * DELETE /api/jobs/:id
 * Delete job (Employer only - own jobs)
 */
export async function deleteJob(req: Request, res: Response): Promise<void> {
  try {
    const employerId = req.user?.id;

    const job = await Job.findOneAndDelete({
      _id: req.params.id,
      employer: employerId,
    });

    if (!job) {
      res.status(404).json({ message: "Job not found or unauthorized" });
      return;
    }

    res.json({ message: "Job deleted successfully" });
  } catch (error) {
    res.status(500).json({ message: "Failed to delete job" });
  }
}

/**
 * PATCH /api/jobs/:id/toggle-status
 * Toggle job active/inactive status (Employer only)
 */
export async function toggleJobStatus(
  req: Request,
  res: Response
): Promise<void> {
  try {
    const employerId = req.user?.id;

    const job = await Job.findOne({
      _id: req.params.id,
      employer: employerId,
    });

    if (!job) {
      res.status(404).json({ message: "Job not found or unauthorized" });
      return;
    }

    // ‚úÖ Toggle isActive v√† set closedAt
    job.isActive = !job.isActive;

    if (!job.isActive) {
      job.closedAt = new Date();
    } else {
      job.closedAt = undefined;
    }

    await job.save();

    res.json({
      message: `Job ${job.isActive ? "opened" : "closed"} successfully`,
      job,
    });
  } catch (error) {
    res.status(500).json({ message: "Failed to toggle job status" });
  }
}

/**
 * GET /api/jobs/employer/my-jobs
 * Get employer's own jobs
 */
export async function getMyJobs(req: Request, res: Response): Promise<void> {
  try {
    const employerId = req.user?.id;

    const jobs = await Job.find({ employer: employerId })
      .populate("company")
      .sort({ createdAt: -1 });

    res.json({ jobs });
  } catch (error) {
    res.status(500).json({ message: "Failed to fetch jobs" });
  }
}

/**
 * POST /api/ai/generate-job-description
 * Generate job description using AI (Employer only)
 */
export async function generateDescription(
  req: Request,
  res: Response
): Promise<void> {
  try {
    const { title, skills, level } = z
      .object({
        title: z.string().min(3),
        skills: z.array(z.string()).min(1),
        level: z.enum(["entry", "mid", "senior", "lead", "executive"]),
      })
      .parse(req.body);

    const description = await generateJobDescription(title, skills, level);

    res.json({ description });
  } catch (error) {
    if (error instanceof z.ZodError) {
      res
        .status(400)
        .json({ message: "Validation error", errors: error.flatten() });
      return;
    }
    res.status(500).json({ message: "Failed to generate description" });
  }
}


// END OF FILE: backend/src/controllers/job.controller.ts

// START OF FILE: backend/src/controllers/profile.controller.ts

import type { Request, Response } from "express";
import { z } from "zod";
import SeekerProfile from "../models/SeekerProfile";
import { uploadToCloudinary } from "../services/cloudinary.service";

const updateProfileSchema = z.object({
  phone: z.string().optional(),
  location: z.string().optional(),
  bio: z.string().max(500).optional(),
  skills: z.array(z.string()).optional(),
  experience: z.string().optional(),
  education: z.string().optional(),
  github: z.string().url().optional().or(z.literal("")),
  portfolio: z.string().url().optional().or(z.literal("")),
  linkedin: z.string().url().optional().or(z.literal("")),
});

export async function getSeekerProfile(
  req: Request,
  res: Response
): Promise<void> {
  try {
    const seekerId = req.user?.id;
    let profile = await SeekerProfile.findOne({ user: seekerId });

    if (!profile) {
      // T·∫°o profile r·ªóng n·∫øu ch∆∞a c√≥
      profile = await SeekerProfile.create({ user: seekerId });
    }

    res.json({ profile });
  } catch (error) {
    res.status(500).json({ message: "Failed to fetch profile" });
  }
}

export async function updateSeekerProfile(
  req: Request,
  res: Response
): Promise<void> {
  try {
    const seekerId = req.user?.id;
    const validated = updateProfileSchema.parse(req.body);

    const profile = await SeekerProfile.findOneAndUpdate(
      { user: seekerId },
      validated,
      { new: true, upsert: true }
    );

    res.json({ message: "Profile updated", profile });
  } catch (error) {
    if (error instanceof z.ZodError) {
      res
        .status(400)
        .json({ message: "Validation error", errors: error.flatten() });
      return;
    }
    res.status(500).json({ message: "Failed to update profile" });
  }
}

export async function uploadAvatar(req: Request, res: Response): Promise<void> {
  try {
    const seekerId = req.user?.id;

    if (!req.file) {
      res.status(400).json({ message: "No file uploaded" });
      return;
    }

    const result = await uploadToCloudinary(req.file.path, "avatars", "image");

    const profile = await SeekerProfile.findOneAndUpdate(
      { user: seekerId },
      { avatar: result.secure_url },
      { new: true, upsert: true }
    );

    res.json({
      message: "Avatar uploaded successfully",
      avatarUrl: result.secure_url,
      profile,
    });
  } catch (error) {
    res.status(500).json({ message: "Failed to upload avatar" });
  }
}

export async function uploadResume(req: Request, res: Response): Promise<void> {
  try {
    const seekerId = req.user?.id;

    if (!req.file) {
      res.status(400).json({ message: "No file uploaded" });
      return;
    }

    const result = await uploadToCloudinary(req.file.path, "resumes", "raw");

    const profile = await SeekerProfile.findOneAndUpdate(
      { user: seekerId },
      { resumeUrl: result.secure_url },
      { new: true, upsert: true }
    );

    res.json({
      message: "Resume uploaded successfully",
      resumeUrl: result.secure_url,
      profile,
    });
  } catch (error) {
    res.status(500).json({ message: "Failed to upload resume" });
  }
}


// END OF FILE: backend/src/controllers/profile.controller.ts

// START OF FILE: backend/src/index.ts

import { app } from "./server";
import { env } from "./utils/env";

const port = Number(env.PORT) || 4000;

app.listen(port, () => {
  console.log(`üöÄ Backend running on http://localhost:${port}`);
});


// END OF FILE: backend/src/index.ts

// START OF FILE: backend/src/middlewares/auth.ts

import type { Request, Response, NextFunction } from "express";
import {
  signAccessToken,
  signRefreshToken,
  verifyAccessToken,
  verifyRefreshToken,
} from "../utils/jwt";
import type { UserRole } from "../types/common";
import User from "../models/User";

export type AuthUser = { id: string; role: UserRole };

declare global {
  namespace Express {
    interface Request {
      user?: AuthUser;
    }
  }
}

// This helper function is similar to the one in the controller.
// For a larger app, it could be moved to a shared utility file.
function setAuthCookies(res: Response, access: string, refresh: string): void {
  const secure = (process.env.COOKIE_SECURE ?? "false") === "true";
  res.cookie("access_token", access, {
    httpOnly: true,
    sameSite: "lax",
    secure,
    path: "/",
  });
  res.cookie("refresh_token", refresh, {
    httpOnly: true,
    sameSite: "lax",
    secure,
    path: "/",
  });
}

export async function requireAuth(
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> {
  const accessToken = req.cookies?.access_token as string | undefined;

  // If access token exists, try to verify it
  if (accessToken) {
    try {
      const payload = verifyAccessToken(accessToken);
      req.user = { id: payload.sub, role: payload.role };
      return next(); // Token is valid, proceed
    } catch (err) {
      // Ignore error, token is invalid or expired, will try to refresh
    }
  }

  // Token is missing or invalid, try to refresh
  const refreshToken = req.cookies?.refresh_token as string | undefined;
  if (!refreshToken) {
    res.status(401).json({ message: "Unauthorized: No tokens provided" });
    return;
  }

  try {
    const refreshPayload = verifyRefreshToken(refreshToken);
    const user = await User.findById(refreshPayload.sub);

    if (!user || !user.isActive) {
      res.status(401).json({ message: "Unauthorized: Invalid user" });
      return;
    }

    // Generate new tokens
    const newAccessToken = signAccessToken(user.id, user.role);
    const newRefreshToken = signRefreshToken(user.id, user.role); // Rotate refresh token

    // Set new tokens in cookies
    setAuthCookies(res, newAccessToken, newRefreshToken);

    // Attach user to request and proceed
    req.user = { id: user.id, role: user.role };
    next();
  } catch (err) {
    // Clear potentially invalid cookies and fail
    res.clearCookie("access_token", { path: "/" });
    res.clearCookie("refresh_token", { path: "/" });
    res.status(401).json({ message: "Unauthorized: Invalid refresh token" });
  }
}

export function requireRole(roles: UserRole[]) {
  return (req: Request, res: Response, next: NextFunction): void => {
    const role = req.user?.role;
    if (!role || !roles.includes(role)) {
      res.status(403).json({ message: "Forbidden" });
      return;
    }
    next();
  };
}


// END OF FILE: backend/src/middlewares/auth.ts

// START OF FILE: backend/src/middlewares/errorHandler.ts

import type { Request, Response, NextFunction } from "express";
import { ZodError, type ZodIssue } from "zod";
import { MongoServerError } from "mongodb";

interface ErrorResponse {
  message: string;
  errors?: Record<string, string[]>;
  stack?: string;
}

/**
 * Advanced Global Error Handler
 * - C√≥ logger hook (t√πy ch·ªçn)
 * - Type m·∫°nh, ch·∫°y ƒë∆∞·ª£c c·∫£ sync & async
 */
export class ErrorHandler {
  private enableDetailedLog: boolean;

  constructor(enableDetailedLog = process.env.NODE_ENV === "development") {
    this.enableDetailedLog = enableDetailedLog;
  }

  // Log errors c√≥ c·∫•u tr√∫c r√µ r√†ng, d·ªÖ t√≠ch h·ª£p logger sau n√†y
  private logError(err: unknown, req: Request) {
    const baseInfo = { method: req.method, url: req.originalUrl };

    if (err instanceof Error) {
      console.error("‚ùå Error:", { ...baseInfo, message: err.message });
      if (this.enableDetailedLog) console.error(err.stack);
    } else {
      console.error("‚ùå Unknown error:", baseInfo, err);
    }
  }

  // Middleware Express ch√≠nh
  public handle = (
    err: unknown,
    req: Request,
    res: Response,
    _next: NextFunction
  ): void => {
    this.logError(err, req); // ‚úÖ Gi·ªù `req` ƒë∆∞·ª£c d√πng th·∫≠t (h·ª£p l·ªá ‚Üí kh√¥ng c√≤n warning)

    // ====== Zod Validation ======
    if (err instanceof ZodError) {
      const errors: Record<string, string[]> = {};
      err.issues.forEach((issue: ZodIssue) => {
        const path = issue.path.join(".");
        if (!errors[path]) errors[path] = [];
        errors[path].push(issue.message);
      });
      res.status(400).json({ message: "Validation error", errors });
      return;
    }

    // ====== Mongo Duplicate Error ======
    if (err instanceof MongoServerError && err.code === 11000) {
      res.status(400).json({ message: "Duplicate entry detected." });
      return;
    }

    // ====== Mongoose Validation ======
    if ((err as any).name === "ValidationError") {
      res.status(400).json({ message: (err as Error).message });
      return;
    }

    // ====== Multer Upload Error ======
    if (err instanceof Error && err.message.includes("File too large")) {
      res.status(400).json({ message: "File size exceeds 5MB" });
      return;
    }

    if (err instanceof Error && err.message.includes("files are allowed")) {
      res.status(400).json({ message: err.message });
      return;
    }

    // ====== Default Server Error ======
    const response: ErrorResponse = {
      message: (err instanceof Error && err.message) || "Internal server error",
    };

    if (this.enableDetailedLog && err instanceof Error) {
      response.stack = err.stack;
    }

    res.status(500).json(response);
  };
}

// C·∫•u h√¨nh export s·∫µn instance m·∫∑c ƒë·ªãnh
export const errorHandler = new ErrorHandler().handle;


// END OF FILE: backend/src/middlewares/errorHandler.ts

// START OF FILE: backend/src/middlewares/rateLimit.ts

import type { Request, Response, NextFunction } from "express";

const rateLimitStore = new Map<string, { count: number; resetAt: number }>();

export function aiRateLimit(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  const identifier = req.ip || req.socket.remoteAddress || "unknown";
  const now = Date.now();
  const limit = parseInt(process.env.AI_RATE_LIMIT_PER_MIN || "5", 10);
  const windowMs = 60 * 1000; // 1 minute

  let record = rateLimitStore.get(identifier);

  if (!record || now > record.resetAt) {
    record = { count: 0, resetAt: now + windowMs };
    rateLimitStore.set(identifier, record);
  }

  if (record.count >= limit) {
    res.status(429).json({
      message: "Too many AI requests. Please try again later.",
      retryAfter: Math.ceil((record.resetAt - now) / 1000),
    });
    return;
  }

  record.count++;
  next();
}

// ‚úÖ Cleanup old entries every 5 minutes
setInterval(() => {
  const now = Date.now();
  for (const [key, value] of rateLimitStore.entries()) {
    if (now > value.resetAt) {
      rateLimitStore.delete(key);
    }
  }
}, 5 * 60 * 1000);


// END OF FILE: backend/src/middlewares/rateLimit.ts

// START OF FILE: backend/src/middlewares/upload.ts

import multer, { type FileFilterCallback } from "multer";
import type { Request } from "express";
import path from "path";
import fs from "fs";

// T·∫°o folder uploads n·∫øu ch∆∞a t·ªìn t·∫°i
const uploadsDir = path.join(__dirname, "../../uploads");
if (!fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir, { recursive: true });
}

// =======================
// 1. Factory t·∫°o b·ªô l·ªçc file
// =======================
export function createFileFilter({
  allowedTypes,
  allowedMimes,
  precheck,
}: {
  allowedTypes: RegExp;
  allowedMimes: RegExp;
  precheck?: (req: Request) => boolean;
}) {
  return (req: Request, file: Express.Multer.File, cb: FileFilterCallback) => {
    try {
      if (precheck && !precheck(req)) {
        return cb(new Error("Upload not allowed for this request"));
      }

      const extValid = allowedTypes.test(
        path.extname(file.originalname).toLowerCase()
      );
      const mimeValid = allowedMimes.test(file.mimetype);

      if (extValid && mimeValid) cb(null, true);
      else cb(new Error(`File type not allowed: ${file.originalname}`));
    } catch (error) {
      cb(error as Error);
    }
  };
}

// =======================
// 2. Config Multer storage
// =======================
const storage = multer.diskStorage({
  destination: (_req, _file, cb) => cb(null, uploadsDir),
  filename: (_req, file, cb) => {
    const uniqueSuffix = `${Date.now()}-${Math.round(Math.random() * 1e9)}`;
    const ext = path.extname(file.originalname);
    cb(null, `${file.fieldname}-${uniqueSuffix}${ext}`);
  },
});

// =======================
// 3. Gi·ªõi h·∫°n dung l∆∞·ª£ng file
// =======================
const MAX_SIZE = 5 * 1024 * 1024; // 5MB

// =======================
// 4. Tr∆∞·ªùng h·ª£p upload ·∫£nh
// =======================
export const uploadImage = multer({
  storage,
  limits: { fileSize: MAX_SIZE },
  fileFilter: createFileFilter({
    allowedTypes: /\.(jpg|jpeg|png|gif|webp)$/i,
    allowedMimes: /^image\//,
    // precheck: (req) => true,  // ‚Üê b·ªè ƒëi·ªÅu ki·ªán role ·ªü ƒë√¢y
  }),
}).single("image");


// =======================
// 5. Tr∆∞·ªùng h·ª£p upload PDF
// =======================
export const uploadPDF = multer({
  storage,
  limits: { fileSize: MAX_SIZE },
  fileFilter: createFileFilter({
    allowedTypes: /\.pdf$/i,
    allowedMimes: /^application\/pdf$/,
    precheck: (_req) => true, // Lu√¥n ƒë∆∞·ª£c ph√©p ‚Äî ai c≈©ng ƒë∆∞·ª£c upload CV
  }),
}).single("resume");


// END OF FILE: backend/src/middlewares/upload.ts

// START OF FILE: backend/src/models/Application.ts

import mongoose, { Schema, Document } from "mongoose";

export type ApplicationStatus =
  | "submitted"
  | "viewed"
  | "accepted"
  | "rejected";

export interface IApplication extends Document {
  job: mongoose.Types.ObjectId;
  seeker: mongoose.Types.ObjectId;
  resumeUrl: string;
  coverLetter?: string; // ‚úÖ ƒë·ªïi t·ª´ note ‚Üí coverLetter
  status: ApplicationStatus;
  viewedAt?: Date; // ‚úÖ C√≥ trong interface
  respondedAt?: Date; // ‚úÖ C√≥ trong interface
  createdAt: Date; // ‚úÖ Th√™m (t·ª´ timestamps: true)
  updatedAt: Date; // ‚úÖ Th√™m (t·ª´ timestamps: true)
}

const applicationSchema = new Schema<IApplication>(
  {
    job: {
      type: Schema.Types.ObjectId,
      ref: "Job",
      required: true,
    },
    seeker: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    resumeUrl: {
      type: String,
      required: true,
    },
    coverLetter: String,
    status: {
      type: String,
      enum: ["submitted", "viewed", "accepted", "rejected"],
      default: "submitted",
    },
    // ‚úÖ TH√äM 2 D√íNG N√ÄY V√ÄO SCHEMA
    viewedAt: { type: Date },
    respondedAt: { type: Date },
  },
  { timestamps: true }
);

// ‚úÖ Index ƒë√∫ng
applicationSchema.index({ job: 1, seeker: 1 }, { unique: true });

export default mongoose.model<IApplication>("Application", applicationSchema);


// END OF FILE: backend/src/models/Application.ts

// START OF FILE: backend/src/models/Company.ts

// models/Company.ts
import mongoose, { Schema, Document } from "mongoose";

export interface ICompany extends Document {
  name: string;
  description?: string;
  website?: string;
  logoUrl?: string;
  owner: mongoose.Types.ObjectId; // employer user
}

const companySchema = new Schema<ICompany>(
  {
    name: { type: String, required: true, unique: true },
    description: String,
    website: String,
    logoUrl: String,
    owner: { type: Schema.Types.ObjectId, ref: "User", required: true },
  },
  { timestamps: true }
);

export default mongoose.model<ICompany>("Company", companySchema);


// END OF FILE: backend/src/models/Company.ts

// START OF FILE: backend/src/models/Job.ts

import mongoose, { Schema, Document } from "mongoose";

// ‚úÖ Enum types theo prompt
export type JobLevel = "entry" | "mid" | "senior" | "lead" | "executive";
export type JobType =
  | "full-time"
  | "part-time"
  | "contract"
  | "internship"
  | "freelance";

export interface IJob extends Document {
  title: string;
  description: string;
  requirements: string[]; // ‚úÖ TH√äM (optional field)
  skills: string[];
  location?: string; // ‚úÖ Optional (kh√¥ng required)
  isRemote: boolean; // ‚úÖ ƒê·ªïi t·ª´ "remote" ‚Üí "isRemote"
  salaryMin?: number; // ‚úÖ Optional
  salaryMax?: number; // ‚úÖ Optional
  level: JobLevel; // ‚úÖ Enum chu·∫©n
  type: JobType; // ‚úÖ TH√äM field type (QUAN TR·ªåNG)
  employer: mongoose.Types.ObjectId;
  company: mongoose.Types.ObjectId;
  isActive: boolean; // ‚úÖ ƒê·ªïi t·ª´ "isOpen" ‚Üí "isActive"
  closedAt?: Date; // ‚úÖ TH√äM field closedAt
  createdAt: Date;
  updatedAt: Date;
}

const jobSchema = new Schema<IJob>(
  {
    title: {
      type: String,
      required: true,
      trim: true,
    },
    description: {
      type: String,
      required: true,
    },
    requirements: {
      // ‚úÖ TH√äM
      type: [String],
      default: [],
    },
    skills: {
      type: [String],
      required: true,
      validate: {
        validator: (v: string[]) => v.length > 0,
        message: "At least one skill is required",
      },
    },
    location: String, // ‚úÖ Optional (kh√¥ng required)
    isRemote: {
      // ‚úÖ ƒê·ªïi t√™n
      type: Boolean,
      default: false,
    },
    salaryMin: {
      // ‚úÖ Optional + validation
      type: Number,
      min: 0,
    },
    salaryMax: {
      // ‚úÖ Optional + validation
      type: Number,
      min: 0,
    },
    level: {
      type: String,
      enum: ["entry", "mid", "senior", "lead", "executive"], // ‚úÖ Lowercase theo prompt
      required: true,
    },
    type: {
      // ‚úÖ TH√äM field type (B·∫ÆT BU·ªòC)
      type: String,
      enum: ["full-time", "part-time", "contract", "internship", "freelance"],
      required: true,
    },
    employer: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    company: {
      type: Schema.Types.ObjectId,
      ref: "Company",
      required: true,
    },
    isActive: {
      // ‚úÖ ƒê·ªïi t√™n t·ª´ isOpen
      type: Boolean,
      default: true,
    },
    closedAt: Date, // ‚úÖ TH√äM field closedAt
  },
  { timestamps: true }
);

// ‚úÖ Indexes cho performance
jobSchema.index({ createdAt: -1 });
jobSchema.index({ isActive: 1 });
// ‚úÖ Text index cho search
jobSchema.index({ title: "text", description: "text", skills: "text" }); // TH√äM skills
export default mongoose.model<IJob>("Job", jobSchema);


// END OF FILE: backend/src/models/Job.ts

// START OF FILE: backend/src/models/SeekerProfile.ts

import mongoose, { Schema, Document } from "mongoose";

export interface ISeekerProfile extends Document {
  user: mongoose.Types.ObjectId;
  phone?: string;
  location?: string;
  bio?: string;
  skills: string[];
  experience?: string;
  education?: string;
  github?: string;
  portfolio?: string;
  linkedin?: string;
  avatar?: string;
  resumeUrl?: string;
}

const seekerProfileSchema = new Schema<ISeekerProfile>(
  {
    user: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: true,
      unique: true,
    },
    phone: { type: String, trim: true },
    location: { type: String, trim: true },
    bio: {
      type: String,
      maxlength: [500, "Bio cannot exceed 500 characters"],
    },
    skills: { type: [String], default: [] },
    experience: String,
    education: String,
    github: { type: String, trim: true },
    portfolio: { type: String, trim: true },
    linkedin: { type: String, trim: true },
    avatar: String,
    resumeUrl: String,
  },
  { timestamps: true }
);

// Index for text search
seekerProfileSchema.index({ skills: "text", bio: "text" });

export default mongoose.model<ISeekerProfile>(
  "SeekerProfile",
  seekerProfileSchema
);


// END OF FILE: backend/src/models/SeekerProfile.ts

// START OF FILE: backend/src/models/User.ts

import { Schema, model, Document } from "mongoose";
import bcrypt from "bcryptjs";
import type { UserRole } from "../types/common";

export interface IUser extends Document {
  email: string;
  password: string;
  name: string;
  role: UserRole;
  isActive: boolean;
  comparePassword(candidate: string): Promise<boolean>;
}

const UserSchema = new Schema<IUser>(
  {
    email: {
      type: String,
      unique: true,
      required: true,
      lowercase: true,
      trim: true,
    },
    password: { type: String, required: true },
    name: { type: String, required: true },
    role: {
      type: String,
      enum: ["seeker", "employer", "admin"],
      default: "seeker",
      required: true,
    },
    isActive: { type: Boolean, default: true },
  },
  { timestamps: true }
);

UserSchema.pre("save", async function (next) {
  if (!this.isModified("password")) return next();
  const salt = await bcrypt.genSalt(10);
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

UserSchema.methods.comparePassword = function (
  candidate: string
): Promise<boolean> {
  return bcrypt.compare(candidate, this.password);
};

export default model<IUser>("User", UserSchema);


// END OF FILE: backend/src/models/User.ts

// START OF FILE: backend/src/routes/admin.routes.ts

import { Router } from "express";
import { requireAuth, requireRole } from "../middlewares/auth";
import {
  getStats,
  getUsers,
  updateUser,
  getAllJobs,
  deleteJobByAdmin,
} from "../controllers/admin.controller";

const router = Router();

router.use(requireAuth, requireRole(["admin"]));

// ‚úÖ Stats
router.get("/stats", getStats);

// ‚úÖ Users management
router.get("/users", getUsers);
router.patch("/users/:userId", updateUser);

// ‚úÖ Jobs management
router.get("/jobs", getAllJobs);
router.delete("/jobs/:jobId", deleteJobByAdmin);

export default router;


// END OF FILE: backend/src/routes/admin.routes.ts

// START OF FILE: backend/src/routes/ai.routes.ts

import { Router } from "express";
import { requireAuth, requireRole } from "../middlewares/auth";
import {
  generateCoverLetterAI,
  summarizeCandidateAI,
} from "../controllers/application.controller";
import { generateDescription } from "../controllers/job.controller";
import { aiRateLimit } from "../middlewares/rateLimit";

const router = Router();

// ‚úÖ Seeker - Generate cover letter
router.post(
  "/generate-cover-letter",
  requireAuth,
  requireRole(["seeker"]),
  aiRateLimit, // ‚úÖ TH√äM
  generateCoverLetterAI
);

// ‚úÖ Employer - Generate job description
router.post(
  "/generate-job-description",
  requireAuth,
  requireRole(["employer"]),
  aiRateLimit, // ‚úÖ TH√äM
  generateDescription
);

// ‚úÖ Employer - Summarize candidate
router.post(
  "/summarize-candidate/:applicationId",
  requireAuth,
  requireRole(["employer"]),
  aiRateLimit, // ‚úÖ TH√äM
  summarizeCandidateAI
);

export default router;


// END OF FILE: backend/src/routes/ai.routes.ts

// START OF FILE: backend/src/routes/application.routes.ts

import { Router } from "express";
import { requireAuth, requireRole } from "../middlewares/auth";
import {
  applyToJob,
  getMyApplications,
  getJobApplications,
  updateApplicationStatus,
  getApplicationById,
  generateCoverLetterAI,
  summarizeCandidateAI,
} from "../controllers/application.controller";
import { uploadPDF } from "../middlewares/upload";

const router = Router();

// Seeker routes
router.post(
  "/jobs/:jobId/apply",
  requireAuth,
  requireRole(["seeker"]),
  uploadPDF,
  applyToJob
);

router.get(
  "/my-applications",
  requireAuth,
  requireRole(["seeker"]),
  getMyApplications
);

router.post(
  "/generate-cover-letter",
  requireAuth,
  requireRole(["seeker"]),
  generateCoverLetterAI
);

// Employer routes
router.get(
  "/jobs/:jobId/applications",
  requireAuth,
  requireRole(["employer", "admin"]),
  getJobApplications
);

router.patch(
  "/:applicationId/status",
  requireAuth,
  requireRole(["employer", "admin"]),
  updateApplicationStatus
);

router.post(
  "/:applicationId/summarize",
  requireAuth,
  requireRole(["employer", "admin"]),
  summarizeCandidateAI
);

// Shared
router.get("/:applicationId", requireAuth, getApplicationById);

export default router;


// END OF FILE: backend/src/routes/application.routes.ts

// START OF FILE: backend/src/routes/auth.routes.ts

import { Router } from "express";
import {
  login,
  logout,
  me,
  refresh,
  register,
} from "../controllers/auth.controller";
import { requireAuth } from "../middlewares/auth";

const router = Router();

router.post("/register", register);
router.post("/login", login);
router.post("/refresh", refresh);
router.post("/logout", logout);
router.get("/me", requireAuth, me);

export default router;


// END OF FILE: backend/src/routes/auth.routes.ts

// START OF FILE: backend/src/routes/company.routes.ts

import { Router } from "express";
import {
  getMyCompany,
  uploadLogo,
  upsertMyCompany,
} from "../controllers/company.controller";
import { requireAuth, requireRole } from "../middlewares/auth";
import { uploadImage } from "../middlewares/upload"; // ‚úÖ TH√äM import

const router = Router();

router.use(requireAuth, requireRole(["employer"]));

router.get("/me", getMyCompany);
router.put("/me", upsertMyCompany);
router.post("/logo", uploadImage, uploadLogo); // ‚úÖ TH√äM d√≤ng n√†y

export default router;


// END OF FILE: backend/src/routes/company.routes.ts

// START OF FILE: backend/src/routes/job.routes.ts

import { Router } from "express";
import { requireAuth, requireRole } from "../middlewares/auth";
import {
  getJobs,
  getJobById,
  createJob,
  updateJob,
  deleteJob,
  toggleJobStatus,
  getMyJobs,
} from "../controllers/job.controller";

const router = Router();

// ============================================
// PUBLIC ROUTES
// ============================================
router.get("/", getJobs);

// ============================================
// EMPLOYER / ADMIN ROUTES (SPECIFIC FIRST!)
// ============================================

// ‚úÖ PH·∫¢I ·ªû TR∆Ø·ªöC /:id
router.get(
  "/employer/my-jobs",
  requireAuth,
  requireRole(["employer"]),
  getMyJobs
);

// ‚úÖ Gi·ªù m·ªõi ƒë·∫øn dynamic routes
router.get("/:id", getJobById);

router.post("/", requireAuth, requireRole(["employer", "admin"]), createJob);

router.put("/:id", requireAuth, requireRole(["employer", "admin"]), updateJob);

router.patch(
  "/:id/toggle-status",
  requireAuth,
  requireRole(["employer", "admin"]),
  toggleJobStatus
);

router.delete(
  "/:id",
  requireAuth,
  requireRole(["employer", "admin"]),
  deleteJob
);

export default router;


// END OF FILE: backend/src/routes/job.routes.ts

// START OF FILE: backend/src/routes/profile.routes.ts

import { Router } from "express";
import { requireAuth, requireRole } from "../middlewares/auth";
import {
  getSeekerProfile,
  updateSeekerProfile,
  uploadAvatar,
  uploadResume,
} from "../controllers/profile.controller";
import { uploadImage, uploadPDF } from "../middlewares/upload";

const router = Router();

router.use(requireAuth, requireRole(["seeker"]));

router.get("/seeker", getSeekerProfile);
router.put("/seeker", updateSeekerProfile);
router.post("/seeker/avatar", uploadImage, uploadAvatar);
router.post("/seeker/resume", uploadPDF, uploadResume);

export default router;


// END OF FILE: backend/src/routes/profile.routes.ts

// START OF FILE: backend/src/seed.ts

// src/seed.ts
import mongoose from "mongoose";
import { connectDB } from "./config/db";
import User from "./models/User";
import Company from "./models/Company";
import Job from "./models/Job";
import SeekerProfile from "./models/SeekerProfile";
import Application from "./models/Application"; // ‚úÖ TH√äM

async function main() {
  await connectDB();

  // üîÑ Xo√° d·ªØ li·ªáu c≈©
  await Promise.all([
    User.deleteMany({}),
    Company.deleteMany({}),
    Job.deleteMany({}),
    SeekerProfile.deleteMany({}),
    Application.deleteMany({}), // ‚úÖ TH√äM
  ]);

  // üë§ Seed ng∆∞·ªùi d√πng
  const admin = await User.create({
    email: "admin@example.com",
    password: "admin123",
    name: "Admin",
    role: "admin",
  });

  const employer = await User.create({
    email: "hr@example.com",
    password: "hr12345",
    name: "HR Manager",
    role: "employer",
  });

  const seeker = await User.create({
    email: "dev@example.com",
    password: "dev12345",
    name: "Dev Seeker",
    role: "seeker",
  });

  // ‚úÖ T·∫°o profile cho seeker
  const seekerProfile = await SeekerProfile.create({
    user: seeker._id,
    phone: "+84 123 456 789",
    location: "Ho Chi Minh City, Vietnam",
    bio: "Passionate developer with 2 years of experience in MERN stack",
    skills: ["JavaScript", "TypeScript", "React", "Node.js", "MongoDB"],
    experience: "2 years in web development",
    education: "Bachelor of Computer Science",
    github: "https://github.com/devseeker",
    portfolio: "https://devseeker.dev",
    linkedin: "https://linkedin.com/in/devseeker",
    resumeUrl:
      "https://res.cloudinary.com/demo/raw/upload/v1234567890/sample_resume.pdf", // ‚úÖ Gi·∫£ l·∫≠p CV c√≥ s·∫µn
  });

  // üè¢ Seed c√¥ng ty
  const company = await Company.create({
    name: "TechCorp Solutions",
    description: "Leading technology company specializing in web solutions",
    website: "https://techcorp.example.com",
    owner: employer._id,
  });

  // üíº Seed jobs
  const job1 = await Job.create({
    title: "Senior Full-Stack Developer",
    description:
      "We are looking for an experienced full-stack developer to join our team",
    requirements: [
      "5+ years of experience in web development",
      "Strong problem-solving skills",
      "Excellent communication skills",
    ],
    skills: ["JavaScript", "TypeScript", "React", "Node.js", "MongoDB"],
    location: "Ho Chi Minh City",
    isRemote: false,
    level: "senior",
    type: "full-time",
    salaryMin: 2000,
    salaryMax: 3500,
    employer: employer._id,
    company: company._id,
    isActive: true,
  });

  const job2 = await Job.create({
    title: "Frontend Developer (React)",
    description: "Join our team to build modern user interfaces",
    requirements: ["3+ years React experience", "TypeScript proficiency"],
    skills: ["React", "TypeScript", "CSS", "Tailwind"],
    location: "Remote",
    isRemote: true,
    level: "mid",
    type: "full-time",
    salaryMin: 1500,
    salaryMax: 2500,
    employer: employer._id,
    company: company._id,
    isActive: true,
  });

  // üìÑ Seed 1 application m·∫´u (seeker apply job1)
  const application = await Application.create({
    job: job1._id,
    seeker: seeker._id,
    resumeUrl: seekerProfile.resumeUrl ?? "",
    coverLetter:
      "Dear HR Manager, I‚Äôm excited to apply for the Senior Full-Stack Developer role at TechCorp. My experience with React and Node.js makes me a strong fit for this position.",
    status: "submitted",
  });

  // üü¢ Log k·∫øt qu·∫£
  console.log("‚úÖ Seed completed successfully!");
  console.table([
    { Role: "Admin", Email: admin.email, Password: "admin123" },
    { Role: "Employer", Email: employer.email, Password: "hr12345" },
    { Role: "Seeker", Email: seeker.email, Password: "dev12345" },
  ]);
  console.log("üè¢ Company:", company.name);
  console.log("üíº Jobs:", job1.title, "+", job2.title);
  console.log("üë§ Seeker profile:", seekerProfile.skills.join(", "));
  console.log("üìÑ Application:",(application.coverLetter ?? "").slice(0, 60) + "...");
  console.log("üì¶ Database:", mongoose.connection.name);

  await mongoose.disconnect();
  process.exit(0);
}

main().catch((e) => {
  console.error("‚ùå Seed error:", e);
  process.exit(1);
});


// END OF FILE: backend/src/seed.ts

// START OF FILE: backend/src/server.ts

import express from "express";
import cors from "cors";
import cookieParser from "cookie-parser";
import { connectDB } from "./config/db";
import { env } from "./utils/env";
import { errorHandler } from "./middlewares/errorHandler"; // ‚úÖ TH√äM

// Import routes
import authRoutes from "./routes/auth.routes";
import companyRoutes from "./routes/company.routes";
import jobRoutes from "./routes/job.routes";
import applicationRoutes from "./routes/application.routes"; // ‚úÖ TH√äM
import profileRoutes from "./routes/profile.routes"; // ‚úÖ TH√äM
import adminRoutes from "./routes/admin.routes"; // ‚úÖ TH√äM
import aiRoutes from "./routes/ai.routes";

export const app = express();

// Core middlewares
app.use(cors({ origin: env.FRONTEND_URL, credentials: true }));
app.use(express.json());
app.use(cookieParser());

// API routes
app.use("/api/auth", authRoutes);
app.use("/api/company", companyRoutes);
app.use("/api/jobs", jobRoutes);
app.use("/api/applications", applicationRoutes); // ‚úÖ TH√äM
app.use("/api/profile", profileRoutes); // ‚úÖ TH√äM
app.use("/api/admin", adminRoutes); // ‚úÖ TH√äM
app.use("/api/ai", aiRoutes); // ‚úÖ TH√äM

// Health check
app.get("/health", (_req, res) => {
  res.json({ status: "ok", time: new Date().toISOString() });
});

// ‚úÖ Global error handler (PH·∫¢I ·ªû CU·ªêI)
app.use(errorHandler);

// Connect to database
connectDB();


// END OF FILE: backend/src/server.ts

// START OF FILE: backend/src/services/cloudinary.service.ts

import { v2 as cloudinary } from "cloudinary";
import fs from "fs";
import { env } from "../utils/env";

// Configure Cloudinary
cloudinary.config({
  cloud_name: env.CLOUDINARY_CLOUD_NAME,
  api_key: env.CLOUDINARY_API_KEY,
  api_secret: env.CLOUDINARY_API_SECRET,
});
interface UploadResult {
  secure_url: string;
  public_id: string;
}

/**
 * Upload file to Cloudinary
 * @param filePath - Local file path
 * @param folder - Cloudinary folder name
 * @param resourceType - 'image' or 'raw' (for PDFs)
 */
export async function uploadToCloudinary(
  filePath: string,
  folder: string,
  resourceType: "image" | "raw" = "image"
): Promise<UploadResult> {
  try {
    const result = await cloudinary.uploader.upload(filePath, {
      folder: `job-portal/${folder}`,
      resource_type: resourceType,
    });

    // Delete temporary file after successful upload
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
    }

    return {
      secure_url: result.secure_url,
      public_id: result.public_id,
    };
  } catch (error) {
    // Delete temporary file on error
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
    }
    throw error;
  }
}

/**
 * Delete file from Cloudinary
 * @param publicId - Cloudinary public ID
 */
export async function deleteFromCloudinary(publicId: string): Promise<void> {
  try {
    await cloudinary.uploader.destroy(publicId);
  } catch (error) {
    console.error("Error deleting from Cloudinary:", error);
    // Don't throw - deletion failure shouldn't break the flow
  }
}


// END OF FILE: backend/src/services/cloudinary.service.ts

// START OF FILE: backend/src/services/gemini.service.ts

import { GoogleGenAI } from "@google/genai";

const apiKey = process.env.GEMINI_API_KEY;
if (!apiKey) {
  throw new Error("GEMINI_API_KEY is not defined in environment variables");
}

const ai = new GoogleGenAI({ apiKey });

/**
 * Generate cover letter using Gemini AI
 * @param jobTitle - Job title
 * @param jobDescription - Job description
 * @param seekerProfile - Seeker's profile info
 */
export async function generateCoverLetter(
  jobTitle: string,
  jobDescription: string,
  seekerProfile: {
    name: string;
    skills: string[];
    experience?: string;
  }
): Promise<string> {
  const prompt = `
Generate a professional cover letter for the following job application:

Job Title: ${jobTitle}
Job Description: ${jobDescription}

Applicant Information:
- Name: ${seekerProfile.name}
- Skills: ${seekerProfile.skills.join(", ")}
${seekerProfile.experience ? `- Experience: ${seekerProfile.experience}` : ""}

Please write a compelling cover letter (max 300 words) that:
1. Shows enthusiasm for the position
2. Highlights relevant skills
3. Explains why the candidate is a good fit
4. Uses a professional tone

Do not include placeholder text like [Your Name] or [Date].
`;

  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: prompt,
    });

    // ‚úÖ FIX: Handle undefined case
    if (!response.text) {
      throw new Error("No response from Gemini API");
    }

    return response.text;
  } catch (error) {
    console.error("Gemini API error:", error);
    throw new Error("Failed to generate cover letter");
  }
}

/**
 * Generate job description using Gemini AI
 * @param jobTitle - Job title
 * @param skills - Required skills
 * @param level - Job level
 */
export async function generateJobDescription(
  jobTitle: string,
  skills: string[],
  level: string
): Promise<string> {
  const prompt = `
Generate a professional job description for:

Position: ${jobTitle}
Required Skills: ${skills.join(", ")}
Level: ${level}

Please create a comprehensive job description (max 400 words) that includes:
1. Role overview
2. Key responsibilities (3-5 bullet points)
3. Required qualifications
4. Nice-to-have skills
5. What makes this position exciting

Use a professional and engaging tone.
`;

  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: prompt,
    });

    // ‚úÖ FIX: Handle undefined case
    if (!response.text) {
      throw new Error("No response from Gemini API");
    }

    return response.text;
  } catch (error) {
    console.error("Gemini API error:", error);
    throw new Error("Failed to generate job description");
  }
}

/**
 * Summarize candidate profile using Gemini AI
 * @param resumeText - Text extracted from resume
 * @param jobRequirements - Job requirements
 */
export async function summarizeCandidate(
  resumeText: string,
  jobRequirements: string
): Promise<string> {
  const prompt = `
Analyze this candidate's resume and provide a 3-line summary focusing on their fit for the job:

Resume:
${resumeText.substring(0, 2000)} // Limit to avoid token limits

Job Requirements:
${jobRequirements}

Provide a concise 3-line summary that highlights:
1. Key strengths
2. Relevant experience
3. Overall fit for the position

Keep it objective and professional.
`;

  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: prompt,
    });

    // ‚úÖ FIX: Handle undefined case
    if (!response.text) {
      throw new Error("No response from Gemini API");
    }

    return response.text;
  } catch (error) {
    console.error("Gemini API error:", error);
    throw new Error("Failed to summarize candidate");
  }
}


// END OF FILE: backend/src/services/gemini.service.ts

// START OF FILE: backend/src/types/common.ts

export type UserRole = "seeker" | "employer" | "admin";


// END OF FILE: backend/src/types/common.ts

// START OF FILE: backend/src/utils/env.ts

import dotenv from "dotenv";
import { z } from "zod";

dotenv.config();

const envSchema = z.object({
  PORT: z.string().default("4000"),
  MONGODB_URI: z.string().min(1, "MONGODB_URI is required"),
  JWT_ACCESS_SECRET: z.string().min(1, "JWT_ACCESS_SECRET is required"),
  JWT_ACCESS_EXPIRES: z.string().default("15m"),
  JWT_REFRESH_SECRET: z.string().min(1, "JWT_REFRESH_SECRET is required"),
  JWT_REFRESH_EXPIRES: z.string().default("7d"),
  FRONTEND_URL: z.string().default("http://localhost:3000"),
  COOKIE_SECURE: z.string().default("false"),

  // ‚úÖ TH√äM Cloudinary
  CLOUDINARY_CLOUD_NAME: z.string().min(1, "CLOUDINARY_CLOUD_NAME is required"),
  CLOUDINARY_API_KEY: z.string().min(1, "CLOUDINARY_API_KEY is required"),
  CLOUDINARY_API_SECRET: z.string().min(1, "CLOUDINARY_API_SECRET is required"),

  // ‚úÖ TH√äM Gemini
  GEMINI_API_KEY: z.string().min(1, "GEMINI_API_KEY is required"),

  // ‚úÖ TH√äM Upload config (optional, c√≥ default)
  MAX_FILE_SIZE: z.string().default("5242880"),
  AI_RATE_LIMIT_PER_MIN: z.string().default("5"),
});

const parsedEnv = envSchema.safeParse(process.env);

if (!parsedEnv.success) {
  console.error("‚ùå Invalid environment variables:", parsedEnv.error.format());
  process.exit(1);
}

export const env = parsedEnv.data;


// END OF FILE: backend/src/utils/env.ts

// START OF FILE: backend/src/utils/jwt.ts

// backend/src/utils/jwt.ts
import jwt, { type SignOptions, type Secret } from "jsonwebtoken";
import type { UserRole } from "../types/common";

// Ki·ªÉu chu·ªói th·ªùi gian h·ª£p l·ªá theo ms (vd: "15m", "7d", "3600", "500ms")
type MsString = import("ms").StringValue;

type Payload = { sub: string; role: UserRole };

function getAccessSecret(): Secret {
  return (process.env.JWT_ACCESS_SECRET ??
    "dev_access_secret_change_me") as Secret;
}
function getRefreshSecret(): Secret {
  return (process.env.JWT_REFRESH_SECRET ??
    "dev_refresh_secret_change_me") as Secret;
}

// Regex ƒë∆°n gi·∫£n ƒë·ªÉ x√°c th·ª±c "s/m/h/d/w/y/ms" ho·∫∑c s·ªë thu·∫ßn (gi√¢y)
const MS_TOKEN_RE = /^\d+(ms|s|m|h|d|w|y)$/i;
const NUMBER_RE = /^\d+$/;

function buildExpiresIn(
  envVal: string | undefined,
  fallback: MsString | number
): SignOptions {
  let expiresIn: MsString | number = fallback;

  if (envVal) {
    if (NUMBER_RE.test(envVal)) {
      // s·ªë thu·∫ßn => d√πng number
      expiresIn = Number(envVal);
    } else if (MS_TOKEN_RE.test(envVal)) {
      // d·∫°ng "15m", "7d", "500ms" => coi l√† MsString
      expiresIn = envVal as unknown as MsString;
    } else {
      // gi√° tr·ªã kh√¥ng h·ª£p l·ªá -> gi·ªØ fallback
    }
  }

  return { expiresIn };
}

export function signAccessToken(userId: string, role: UserRole): string {
  const payload: Payload = { sub: userId, role };
  const secret: Secret = getAccessSecret();
  const options: SignOptions = buildExpiresIn(
    process.env.JWT_ACCESS_EXPIRES,
    "15m" as MsString
  );
  return jwt.sign(payload, secret, options);
}

export function signRefreshToken(userId: string, role: UserRole): string {
  const payload: Payload = { sub: userId, role };
  const secret: Secret = getRefreshSecret();
  const options: SignOptions = buildExpiresIn(
    process.env.JWT_REFRESH_EXPIRES,
    "7d" as MsString
  );
  return jwt.sign(payload, secret, options);
}

export function verifyAccessToken(token: string): Payload {
  return jwt.verify(token, getAccessSecret()) as Payload;
}

export function verifyRefreshToken(token: string): Payload {
  return jwt.verify(token, getRefreshSecret()) as Payload;
}


// END OF FILE: backend/src/utils/jwt.ts

// START OF FILE: backend/src/utils/pagination.ts

export function parsePositiveInt(
  input: string | undefined,
  fallback: number
): number {
  const n = Number(input);
  if (!Number.isFinite(n) || n <= 0) return fallback;
  return Math.floor(n);
}

export function parseBoolean(input: string | undefined): boolean | undefined {
  if (input === undefined) return undefined;
  const s = input.trim().toLowerCase();
  if (["true", "1", "yes"].includes(s)) return true;
  if (["false", "0", "no"].includes(s)) return false;
  return undefined;
}


// END OF FILE: backend/src/utils/pagination.ts

// START OF FILE: backend/tsconfig.json

{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}


// END OF FILE: backend/tsconfig.json

